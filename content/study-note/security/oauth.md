# OAuthについて
## OAuthとは
### OAuthの目的
OAuth（オーオース）とは、  
**「他のサービスに自分のデータへのアクセスを安全に許可するための仕組み」**です。  

### 認証（Authentication）と認可（Authorization）の違い
OAuthを理解する前に、2つの言葉の違いをおさえておきましょう：  

| 用語                     | 意味              | 例                      |
| ---------------------- | --------------- | ---------------------- |
| **認証（Authentication）** | 本人確認（あなたは誰？）    | ログインIDとパスワードを使って本人確認   |
| **認可（Authorization）**  | アクセス許可（何をしていい？） | 特定のファイルを見たり、書き込んだりする許可 |

OAuthは「認可」の仕組みです。  
「本人確認」は別の仕組み（後述する OpenID Connect など）と組み合わせることもあります。

### OAuthの主な特徴まとめ
| 特徴                   | 内容                           |
| -------------------- | ---------------------------- |
| 🔐 パスワードを渡さない        | 他のアプリに自分のログイン情報を教える必要がない     |
| ⏱️ 一時的な「鍵」でアクセス      | 有効期限付きのアクセストークンを使う           |
| ✅ ユーザーが許可した範囲だけ操作できる | アクセス範囲（scope）を制御できる          |
| 🔁 サードパーティアプリでも使える   | Google、Twitterなど大手APIが対応している |


## OAuthの登場背景と必要性
### なぜOAuthが生まれたのか
かつて、あるアプリが別のサービス（たとえばTwitterやGoogle）と連携するには：  
🔓 ユーザーの「ログインIDとパスワード」を直接アプリに渡すしかなかった  
つまり、「信頼してないアプリにログイン情報を渡す」しか方法がなかったのです。  

### 問題点：パスワード共有は危険だらけ
| 問題                 | 内容                         |
| ------------------ | -------------------------- |
| ❌ セキュリティリスク        | パスワードが漏洩すれば全権限を奪われる        |
| ❌ パーミッション制御できない    | 「読み取りだけ許可」「書き込みだけ禁止」などが不可能 |
| ❌ ログイン情報の使い回し      | 別サービスに再利用される恐れあり（悪用）       |
| ❌ パスワードを変えたら再連携が必要 | ユーザー体験が悪い                  |

### 解決策：OAuthの誕生
これらの問題を解決するために登場したのが OAuth（Open Authorization）です。  

OAuthはこう考えます：  
「自分のアカウントの“鍵”を、アプリに一時的に貸し出す」という仕組みにすれば、  
パスワードを共有せずに、安全にサービス連携ができる！  

### OAuthのメリット（なぜ必要だったか）
| メリット             | 説明                      |
| ---------------- | ----------------------- |
| 🔐 パスワード非公開      | 他のアプリにログイン情報を渡さずにすむ     |
| 🎯 アクセス制限ができる    | 読み取りのみ許可、投稿は禁止…など細かく設定可 |
| 🕒 一時的なアクセス      | トークンには有効期限があるため、安全性が高い  |
| 🚪 いつでもアクセス撤回できる | アプリごとに許可を取り消せる（ユーザー主体）  |


## OAuthの登場人物と役割
OAuthは「安全にアクセス権を他のサービスに渡す」ための仕組みですが、  
その中で 4つの登場人物（コンポーネント） が登場します。

### リソースオーナー（ユーザー）
- 誰か？：ユーザー本人（＝自分のGoogleアカウントなど）
- 役割：アクセス権の持ち主として、「このアプリにこの範囲で許可してよい」と判断する

### クライアント（アプリ）
- 誰か？：アクセスを受けたい側、つまり外部アプリ・サービス
- 役割：ユーザーの許可を得て、アクセストークンを取得し、APIにアクセスする

- 例：  
  - Googleカレンダーを読み取る分析アプリ  
  - Slackに自動投稿するBotアプリ  

### 認可サーバー
- 誰か？：ユーザーの認可を管理し、アクセストークンを発行する存在
- 役割：
  - ユーザーにログインと同意を促す
  - 同意された範囲でトークンを発行する

- 例：
  - Googleアカウントのログイン画面や、Salesforceの認可エンドポイント

### リソースサーバー
- 誰か？：実際にユーザーのデータを保持しているサーバー
- 役割：クライアントからのリクエストを受け、アクセストークンを検証してデータを提供

### まとめ
| 登場人物     | 立場              | 主な役割                |
| -------- | --------------- | ------------------- |
| リソースオーナー | ユーザー            | 自分のデータのアクセスを許可・拒否する |
| クライアント   | 外部アプリ           | アクセス権をもらい、APIを使う    |
| 認可サーバー   | サービス側（例：Google） | 認可処理とトークン発行を行う      |
| リソースサーバー | データ保持側          | トークンを検証し、リソースを返す    |

```markdown
[User] ─────────────┐
                    ▼
             [Authorization Server] ─── issues ──▶ [Access Token]
                    ▲                                ▼
[Client App] ───────┘                          [Resource Server]
                        uses token ────────────────▶
```

## OAuthの種類
OAuthには大きく分けて2つのバージョンがあります：
- OAuth 1.0a（古い／署名ベース）
- OAuth 2.0（現在の標準／トークンベース）

### OAuth 1.0a（署名ベース）
主な特徴：
- 署名（Signature）ベースの認証
- HMAC-SHA1などで毎リクエスト署名を計算して送信
- 複雑だがセキュア（改ざん耐性がある）

認証フローの例：
- (1) リクエストトークン取得
- (2) ユーザーの認可
- (3) アクセストークン取得
- (4) APIアクセス

弱点：
- 実装が複雑
- HTTPSではなく署名ベースで安全性を担保
- モバイル／ブラウザアプリに不向き

### OAuth 2.0（トークンベース）
主な特徴：
- アクセストークンベースの認可
- 通信の安全性は HTTPS に依存（署名不要）
- トークン管理が柔軟（スコープ／有効期限／リフレッシュトークン）

よく使われるフロー（Grant Type）：
| フロー名                                     | 概要                  | 主な用途       |
| ---------------------------------------- | ------------------- | ---------- |
| Authorization Code                       | サーバー間通信を使い安全にトークン取得 | Webアプリ     |
| Client Credentials                       | サーバー to サーバー        | バッチ処理など    |
| Implicit（非推奨）                            | ブラウザ用、セキュリティに弱点     | 古いSPAアプリ   |
| Resource Owner Password Credentials（非推奨） | ユーザーのID/パスワードを直接使う  | 信頼されたアプリのみ |

メリット：
- 柔軟で拡張性が高い
- モバイル／SPA／サーバー間すべて対応可
- OIDC（OpenID Connect）などと統合しやすい

弱点：
- 実装ミスによるセキュリティ事故のリスクあり（設計が柔軟すぎるため）

### OAuth 1.0a と 2.0 の比較表
| 比較項目    | OAuth 1.0a       | OAuth 2.0           |
| ------- | ---------------- | ------------------- |
| 認証方式    | 署名ベース（HMAC）      | トークンベース（Bearerトークン） |
| HTTPS必須 | なくてもよい（署名あり）     | 必須（署名なし）            |
| 実装の簡易さ  | 複雑               | 比較的簡単               |
| 拡張性     | 低い               | 高い（OIDC等）           |
| 主な用途    | 古いAPI（Twitterなど） | 現代のWeb／API認可の標準     |


## OAuth 2.0の基本フロー
OAuth 2.0では、「外部アプリに一時的なアクセス権（トークン）を発行する」ことで、安全にデータへアクセスさせます。  
ここでは、最も一般的な Authorization Code Flow（認可コードフロー） を中心に解説します。

### 認可コードフローの全体像
- (1) ユーザーがアプリを使い始める
- (2) アプリが認可サーバーへリダイレクト（ログイン画面へ）
- (3) ユーザーがログイン＆アプリにアクセスを許可
- (4) 認可サーバーが **認可コード（Authorization Code）** を返す
- (5) アプリがそのコードを使ってアクセストークンを取得
- (6) アクセストークンでAPIにアクセス

### 各ステップの詳細
#### 1. クライアントが認可リクエスト
```plaintext
GET /authorize?
  response_type=code&
  client_id=xxxx&
  redirect_uri=https://yourapp.com/callback&
  scope=email calendar&
  state=abc123
```

→ ユーザーは 認可サーバーの画面でログイン＆同意 します

#### 2. 認可サーバーが認可コードを返す
```plaintext
302 Found
Location: https://yourapp.com/callback?code=xyz123&state=abc123
```

#### 3. クライアントがトークンを取得（サーバー間通信）
```plaintext
POST /token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
code=xyz123&
redirect_uri=https://yourapp.com/callback&
client_id=xxxx&
client_secret=yyyy
```

→ 成功すれば、次のようなレスポンスが返る：

```plaintext
{
  "access_token": "abcd1234",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "refresh5678"
}
```

#### 4. アクセストークンを使ってAPIにアクセス
```plaintext
GET /user/calendar
Authorization: Bearer abcd1234
```
→ このリクエストには、アクセストークンが必須  
→ リソースサーバーはトークンを検証し、許可された範囲でデータを返す

### アクセストークンとリフレッシュトークン
| 種類         | 用途               | 有効期限       | 主な使い方             |
| ---------- | ---------------- | ---------- | ----------------- |
| アクセストークン   | APIにアクセスする鍵      | 短い（数分～数時間） | 通常のAPIリクエストに使用    |
| リフレッシュトークン | 新しいアクセストークンをもらう鍵 | 長い（または無期限） | 再ログインせずにトークン更新が可能 |

### スコープ（scope）の使い方
- scopeは「どの操作を許可するか」を細かく指定する
- 例：scope=email profile calendar.readonly

→ ユーザーに「このアプリにメールとカレンダーの読み取りを許可しますか？」と確認画面が出る

### まとめ：OAuth 2.0のフローのキモ
- ユーザーの同意を通してトークンを発行
- アクセストークンでAPIアクセス
- スコープ・有効期限・リフレッシュの仕組みで安全性を確保

## OAuth 1.0a の仕組みと使い方
OAuth 1.0a は、2007年ごろに登場した 初期バージョンのOAuth です。  
現在では主に OAuth 2.0 に置き換わっていますが、古いAPIでは今でも使われていることがあります。

| 特徴                  | 説明                        |
| ------------------- | ------------------------- |
| 🔐 通信の署名が必須         | 各リクエストにHMAC-SHA1などで署名をつける |
| ❌ HTTPSは不要（署名があるから） | ただし現在は併用が推奨される            |
| 🔁 トークンの取得が2段階      | 「リクエストトークン」と「アクセストークン」    |

### 概要
- **クライアント（リクエスト元）** は、
  - リクエスト情報（HTTPメソッド、URL、パラメータ、タイムスタンプなど）と、
  - 自分の **秘密鍵（consumer secret / token secret）** を使って、
  - 特定のロジック（HMAC-SHA1 など）で oauth_signature を生成します。
- **サーバー側（リソースサーバーなど）** は、
  - 同じロジックを使って自力で署名を再生成し、
  - リクエストに含まれる oauth_signature と一致するかどうかを比較して検証します。

```plaintext
リクエスト送信側：
  リクエスト情報 + 秘密鍵 → oauth_signature を生成 → リクエストに含める

サーバー側：
  同じ手順で署名を再生成 → 受信した oauth_signature と比較 → 検証OK/NG
```

### 目的：本当に想定している相手かどうかを判断
- 第三者が同じ署名を作ることはできない（秘密鍵が必要）
- リクエストの改ざん防止（署名に全リクエストパラメータが含まれる）
- リプレイ攻撃防止のために oauth_timestamp と oauth_nonce を使用（同じリクエストを再送しても通らない）

### 認証の流れ（OAuth 1.0a）
#### 1. リクエストトークンの取得
- アプリは consumer_key などを使って署名付きリクエストを送る
- 認可サーバーから「リクエストトークン」が返る

#### 2. ユーザーの認可
- アプリがブラウザでユーザーを認可画面へリダイレクト
- ユーザーが同意すると oauth_verifier が返ってくる

#### 3. アクセストークンの取得
- リクエストトークン + oauth_verifier を使ってアクセストークンを取得

#### 4. APIアクセス
- Authorization ヘッダーに oauth_signature などの情報を含めてリクエスト

### Authorizationヘッダー例（OAuth 1.0a）
```plaintext
Authorization: OAuth
  oauth_consumer_key="abc123",
  oauth_token="def456",
  oauth_signature_method="HMAC-SHA1",
  oauth_timestamp="1623456789",
  oauth_nonce="randomstring",
  oauth_version="1.0",
  oauth_signature="計算された署名"
```

### OAuth 1.0aの注意点
- 署名アルゴリズムの実装がやや複雑（毎回署名を計算）
- 通信ごとに nonce や timestamp を使う必要がある
- 多くのAPIがすでにOAuth 2.0へ移行している（Twitterも2023年にv1.1終了）

### 使われるケース
- 一部のレガシーAPI（OAuth 2.0未対応）
- 独自仕様でOAuth 1.0ベースの認証を持つアプリ

### まとめ
✅ 「リクエスト元が想定している相手かどうか」を、秘密鍵を使った署名と復元検証によって保証している。  
これは一種の「メッセージ署名（Message Signing）」であり、  
OAuth 2.0 では BearerトークンとHTTPS によってこの署名の役割を分離・簡素化しています。

## Authorizationヘッダーとトークンの使い方
OAuth 2.0では、アクセストークンを使ってユーザーのデータにアクセスします。  
このとき、アクセストークンはHTTPリクエストのヘッダーに含めるのが一般的です。

### Authorizationヘッダーの基本形
```plaintext
Authorization: Bearer アクセストークン
```

この形式で送信することで、リソースサーバーは「このリクエストは認可されたものかどうか」を検証します。

### トークン送信の方法（一般的な3パターン）
| 方法                       | 説明                              | 推奨度                     |
| ------------------------ | ------------------------------- | ----------------------- |
| **1. Authorizationヘッダー** | `Authorization: Bearer トークン`    | ✅ 一番一般的・推奨              |
| 2. クエリパラメータ              | `?access_token=xxx`             | ❌ 推奨されない（URLに残る）        |
| 3. フォームボディ               | `access_token=xxx` をPOSTボディに含める | △ 特定用途向け（例：tokenリクエスト時） |

### アクセストークンの検証方法（サーバー側）
- (1) トークンが有効か？
  - DBやJWTで確認
- (2) 有効期限は切れていないか？
  - exp クレームや発行日時を見る
- (3) スコープは適切か？
  - トークンに付与された scope と照らし合わせる

### 注意点：Bearerトークンの脆弱性
- トークンを盗まれると誰でも使える（パスワードと同じ）
- HTTPS通信は必須（暗号化しないと盗聴されるリスク）
- ストレージ・ログに残らないよう注意

### まとめ
- トークンは通常 Authorization: Bearer 形式で送信
- サーバーはそのトークンが「誰にいつ発行されたものか」を検証
- HTTPSを前提として設計されているため、通信の暗号化が必須

## リフレッシュトークンと有効期限
OAuth 2.0では、 **アクセストークンの寿命（有効期限）** が短く設計されています。  
そのため、ユーザーに再ログインさせずに新しいトークンを取得する仕組みとして「リフレッシュトークン（refresh token）」が用意されています。

### アクセストークンとリフレッシュトークンの違い
| トークン種類     | 用途                | 有効期限       | セキュリティ上の注意        |
| ---------- | ----------------- | ---------- | ----------------- |
| アクセストークン   | APIアクセス用          | 数分〜数時間程度   | 短命で使い捨てが基本        |
| リフレッシュトークン | 新しいアクセストークンの取得に使用 | 長い（数日〜数ヶ月） | より機密性が高い、厳重な管理が必要 |

### リフレッシュトークンを使うタイミング
- (1) アクセストークンでAPIを呼び出す
- (2) 「トークンの有効期限が切れている」というエラーを受け取る
- (3) リフレッシュトークンを使って新しいアクセストークンを取得

### リフレッシュトークンの使い方(例)
```plaintext
POST /token
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token
&client_id=abc123
&client_secret=xyz456
&refresh_token=long_refresh_token_value
```

レスポンス例:

```json
{
  "access_token": "new_access_token",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

### リフレッシュトークンのセキュリティ対策
- 漏洩すると永続的にトークンを再取得できてしまう
- ストレージ（DB/ブラウザ）に保存する場合は暗号化 or Secure属性のCookieを推奨
- 使用時にはclient_secretの提示が必要（＝認証されているクライアントしか使えない）

### 実運用での活用例
- Webアプリ：ユーザーのログイン状態を長時間維持しつつ、アクセストークンだけを短命に
- モバイルアプリ：自動的にトークン更新し、ユーザーに負担をかけない設計が可能

### まとめ
- アクセストークンには短い有効期限があり、期限切れ時にはリフレッシュトークンを使って更新
- リフレッシュトークンは機密性が高いため、取り扱いに注意
- セキュアな設計があれば、長期的な認証維持が可能

## セキュリティ上の注意点とベストプラクティス
OAuth 2.0は便利な仕組みですが、設計や実装を誤ると重大な情報漏洩や乗っ取りにつながります。

### 1. HTTPSは必須
- アクセストークンは「持っているだけでアクセスできる」ため、盗まれると即アウト
- 通信経路を暗号化して **中間者攻撃（MITM）** を防ぐためにも、すべての通信をHTTPSで

### 2. トークンをローカルに保存する際の注意
- ブラウザ：localStorageよりもSecure + HttpOnlyなCookieの方が安全
- モバイルアプリ：暗号化ストレージを使用（KeychainやKeystore）

### 3. スコープを限定する
- トークンに含めるスコープは最小限に限定
- 例：read_profile だけ必要なら read_profile calendar.write は避ける
- **最小権限の原則（least privilege）** を徹底

### 4. アクセストークンの寿命は短く
- 万が一盗まれても、短時間で使えなくなるように設計
- リフレッシュトークンで更新しつつ、アクセストークンは1時間未満がおすすめ

### 5. トークンの検証を適切に行う
- JWTの場合：
  - 署名の検証（正しい秘密鍵か）
  - 期限切れかどうか（exp）
  - 発行者や対象者が正しいか（iss / aud）

### 6. CSRF対策をする（特に認可コードフロー）
- 認可リクエストには state パラメータを使用して、
  - セッションと結びつける
  - リダイレクト時に検証する

### 7. トークンの取り消し（Revoke）機能を設ける
- ユーザーが「アプリの接続を解除」したいときに対応できるように
- トークンの取り消し用エンドポイント /revoke を用意する

### 8. 信頼できるクライアントのみリフレッシュトークンを許可
- client_secret を安全に保持できないSPAやJavaScriptアプリには、リフレッシュトークンを発行しない設計もアリ

### 9. ログの取り扱いに注意
- トークンやAuthorizationヘッダーをログに出力しない
- エラーログやアクセスログの出力時は、個人情報・認証情報をマスク

### まとめ：安全なOAuth実装のために
| 対策カテゴリ   | 具体的な内容              |
| -------- | ------------------- |
| 通信の安全性   | HTTPS強制、MITM対策      |
| トークン管理   | スコープ制限、期限短縮、安全な保存   |
| フローの健全性  | `state`パラメータでCSRF防止 |
| クライアント制御 | 信頼できるアプリにのみ強い権限     |
| ユーザー制御   | Revoke、セッションの終了機能   |

