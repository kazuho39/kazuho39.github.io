# ドメイン駆動設計の基礎知識

## ドメイン駆動設計とは

ドメイン駆動設計は、業務仕様やナレッジとコードを一体化させる手法。

業務の実現や顧客の課題解決が第一であり、最新の技術や開発手法の活用は必須ではない。

### ドメイン駆動設計の原則

- 業務仕様やビジネスルールの複雑さを紐解き、顧客の課題を正しく理解する
- 業務の専門家とソフトウェアの専門家が協力し、ドメインモデルを作る
- ドメインモデルを明示的に表現することを書き、ソフトウェアを作る
- エンジニアである方もそうでない方(業務担当者など)も理解できる共通言語を使って会話する

## 用語

### ドメイン

「プログラムを適用する対象となる領域」を指す。「ドメインに含まれるものは何か」を整理することが重要。

システムにより解決すべき課題の多くは、ビジネスルールをどう実現するかということが出発点。このため、開発にあたる技術者には顧客の業務と真摯に向き合うことが要求される。

### モデル、モデリング

**モデル**とは、現実の事象、あるいは概念を抽象化した概念のこと。

事象、あるいは概念を抽象化してモデルを定める作業を**モデリング**と呼ぶ。

### ドメインモデル

ドメインの概念をモデリングして得られたモデルが**ドメインモデル**。

そして、ドメインモデルをソフトウェアで動作するモジュール(コード)として表現したものが**ドメインオブジェクト**。

ドメインの変化はドメインモデルを媒介にして、連鎖的にドメインオブジェクトまで伝えられる。

### ユビキタス言語

プロジェクトにおける共通言語。

会話やドキュメントだけでなく、コードにも利用する。

### コンテキスト

ドメインの国境のようなもの。

## DDDをシステムで実現するための構成

- **知識を表現するパターン**
    - **値オブジェクト**
        - システム固有の値を表現するために定義されたオブジェクト
    - **エンティティ**
        - 値オブジェクトと同じくドメインモデルを実装したドメインオブジェクト
        - 値オブジェクトとの違いは、同一性(Identity)によって識別されるか否か
    - **ドメインサービス**
        - 値オブジェクトやエンティティでは表現できない知識を取り扱うためのパターン
- **アプリケーションを実現するためのパターン**
    - **リポジトリ**
        - データの保存や復元といった永続化や再構築を担当するオブジェクト
    - **アプリケーションサービス**
        - ユースケースを実現するオブジェクト
    - **ファクトリ**
        - オブジェクトを生成するときに複雑な処理が必要になるときに使用
        - オブジェクト生成のロジックをファクトリに実装することで、インスタンスの生成をファクトリ経由で行うようにする
- **知識を表現する、より発展的なパターン**
    - **集約**
        - 外部から内部のオブジェクトに対して直接操作するのではなく、オブジェクトに依頼するような形を取る
    - **仕様**
        - 評価の条件や手順をモデルにしたオブジェクト

---

# 知識を表現するドメインオブジェクト

**「値オブジェクト」「エンティティ」「ドメインサービス」**は、ドメインの知識をオブジェクトとして表現するドメインオブジェクト。ドメインオブジェクトは、ソフトウェアの製造工程よりも、その後の保守開発において際立つ。

- **(1) コードのドキュメント性が高くなる**
    - ドメインモデルに渦巻くルールはそのままドメインオブジェクトに記述されるため、コードから仕様を読み解きやすくなる
- **(2) ドメインにおける変更をコードに伝えやすくなる**
    - ドメインオブジェクトにふるまいやルールを記述すると、ドメインにおける変更をコードに反映しやすくなる

## 値オブジェクト

システム固有の値を表現するために定義されたオブジェクトを、**値オブジェクト**と呼ぶ。

値オブジェクトはデータを保持するコンテナではなく、ふるまいを持つことができるオブジェクト。

### 値の３つの代表的な性質

- **(1) 不変である**
- **(2) 交換が可能である**
    - 値オブジェクトの変更は、代入操作によって交換をすることで表現される。
- **(3) 等価性によって比較される**
    - 値オブジェクト同士で比較できるようにするため、値オブジェクトが比較するためのメソッドを用意する
    - その属性を取り出して比較をするのではなく、値と同じように値オブジェクト同士が比較できるようにする方が自然な記述

### 値オブジェクトにする基準

- **そこにルールが存在しているか**
- **それ単体で扱いたいか**

### 値オブジェクトを使う4つのモチベーション

- **(1) コードの表現力を増す**
- **(2) 不正な値を存在させない**
    - 値オブジェクトのコンストラクタに**ガード節(チェックロジック)**を入れることで、業務上不正な値が発生しないようにできる
- **(3) 誤った代入を防ぐ**
    - int型であれば、「数量」と「代金」はプログラム上同じ扱いになるため、誤って代入してしまうことがありうる
    - それぞれ値オブジェクトになっていれば、コンパイルエラーなどで検知することができる
- **(4) ロジックの散在を防ぐ(DRY原則)**
    - 値オブジェクトに関するルールやチェック処理を1箇所にまとめることができる

## エンティティ

値オブジェクトとの違いは、同一性(Identity)によって識別されるか否か。

### エンティティの性質

- **(1) 可変である**
    - エンティティの属性は、変化することが許容されている
        - 人々が持つ年齢や身長といった属性が変化するのと同じ
    - 無味無色のsetterによってユーザ名の交換を行わない
        - メソッド名により、そのふるまいが何であるか分かる
- **(2) 同じ属性であっても区別される(属性だけでは区別できない)**
    - ex. 同姓同名だが、2つは異なるユーザ(別人物)である
- **(3) 同一性により区別される**
    - 識別子(Identity)を利用する

### エンティティの判断基準

何を値オブジェクトにして、何をエンティティにするか。

**ライフサイクルが存在し、そこに連続性が存在するか**は大きな判断基準である。

- ex. ユーザ(User)
    - ユーザ登録によって作成され、退会などにより不要になれば削除される
    - ユーザは、ライフサイクルを持ち連続性のある概念であるといえる

## ドメインサービス

ドメインに関するロジックだが、値オブジェクトやエンティティには記述できないようなふるまいを実装するためのオブジェクト。複数のドメインオブジェクトを横断するような操作をする際に活用する。

ドメインサービスにロジックを書きすぎると、値オブジェクトやエンティティがふるまいを持たない「無口なオブジェクト」になってしまいがちなので注意。

# **アプリケーションを実現するためのパターン**

アプリケーションとして動かすために構築する部分。

## リポジトリ

リポジトリは、データを永続化し再構築するといった処理(DBへの保存、取得)を抽象的に扱うためのオブジェクト。

インターフェース(抽象型)で定義される。呼び出し元(主にアプリケーションサービス)で必要になったメソッドをインターフェースに定義し、それを実装していく。

## アプリケーションサービス

ユースケースを実現するオブジェクト。あくまでもドメインオブジェクトのタスク調整を行う役割であるため、ドメインのルールを記述されるべきではない。

## ファクトリ

オブジェクトを生成するときに複雑な処理が必要になるときに使用。

オブジェクト生成のロジックをファクトリに実装することで、インスタンスの生成をファクトリ経由で行うようにする。

クラス自体がファクトリとなるだけでなく、メソッドがファクトリとして機能するケースもある。(ex. オブジェクトの内部データを利用してインスタンスを生成する)

# **知識を表現する、より発展的なパターン**

## 集約

複数のオブジェクトがまとめられ、ひとつの意味をもったオブジェクト。

集約の外部から境界の内部のオブジェクトを直接操作してはいけない。それを保持するオブジェクト(集約ルート)に依頼する形を取る。

オブジェクトに記述されるべきルールが散在しないようにするための考え方。

## 仕様

評価の条件や手順をモデルにしたオブジェクト。

エンティティや値オブジェクトにロジックを埋め込まないようにするため、複雑な評価手順をクラスとして切り出す。**ドメインサービス**のひとつの形。

仕様はオブジェクトの評価のみを行う。

オブジェクトの評価処理をオブジェクト自身にメソッドとして実装するだけではなく、外部のオブジェクトとして切り出すことも考慮する。

### リポジトリと組み合わせる

検索処理の中には、重要なルールを含むものが存在する。それをリポジトリのメソッドとして定義してしまうと、重要なルールがリポジトリの実装クラスに記述されてしまう。

重要なルールを仕様オブジェクトとして定義し、リポジトリに渡して検索処理を実行するような手法もある。

# DDDで作成するもの

- 業務フロー図
- ユースケース図
- ドメインモデル図
- ユビキタス言語

## 業務フロー図

既存の業務の流れを図示したもの。これを作成することで、全体を俯瞰した上でシステム化する対象範囲を決めることができる。

## ユースケース図

業務フロー図で明確になったシステムの対象範囲について、もう少しブレークダウンして誰がどういう使い方(操作)をするシステムなのかを「ユーザ目線で」記載していく。

## ドメインモデル図

ドメインモデル図には以下の内容を書いていく。

- オブジェクトと代表的な属性
- ルール・制約
- 集約(データベースにまとめて保存したいオブジェクトのまとまり)

重要なのは「ルール・制約」で、こちらにどれだけ重要な事項を記載できるかがポイントになる。下記の図はまだ不十分で、例えば「人員」オブジェクトの役割にはどういったものがあるの？という疑問が浮かんだら、議論してどんどん追記していくようにする。

ここに記載したオブジェクトがDDDではそのままクラスとなり、このクラスにどれだけ現実に沿ったルール・制約を詰め込めるかが重要になる。

今までも「**データの構成整理、認識合わせ**」をするために、こういった図を作成したことがあった。**DBのテーブル設計**目的にも作ったことがある。

**今後はそれをドメインモデル図として役立てていけるように意識**してみる。

## ユビキタス言語

プロジェクトにおける共通言語のこと。認識の齟齬や翻訳にコストを掛けないようにすることが目的。ドメインエキスパートとの会話、開発者同士の会話だけでなく、コードにもユビキタス言語を使用する。

「ユーザの名前を変更する」という表現がドメインにとって自然な表現であれば、コードも「名前を変更する」という言葉を忠実に表現すべきであり、ChangeNameというメソッド名になるべき。これにより「名前を変更する」ルールに変更が入った際に、ChangeNameメソッドを修正することの正当性が確認できる。

顧客や開発者と会話する際、**認識齟齬を起こさないようにするために、ドキュメントに記載した言葉を使って会話することがあった**。

今後はそれを**ユビキタス言語のディクショナリを作って視覚化し、蓄積していけるように意識**してみる。

# DDDをアプリケーションとして実現するためのアーキテクチャ

DDDと同時に語られることの多いアーキテクチャはいくつもある(レイヤードアーキテクチャ、ヘキサゴナルアーキテクチャ、クリーンアーキテクチャ)。

自分としてはこの中で**レイヤードアーキテクチャ**を採用する。

## レイヤードアーキテクチャ

いくつかの層が積み重なる形で表現される。レイヤードアーキテクチャを構成する4つの層の内訳は次のとおり。

- プレゼンテーション層(ユーザーインターフェース層)
- アプリケーション層
- ドメイン層
- インフラストラクチャ層

### プレゼンテーション層

UIとアプリケーションを結びつける。主な責務は表示と解釈。
ユーザーインターフェース（UI）や、ユーザーとアプリケーションの間でデータをやり取りする部分。

### アプリケーション層

ドメイン層を取りまとめる。**アプリケーションサービス**はここに入る。ユースケースを実現するための進行役になる。
ビジネスロジックやユースケースを実行する層。
プレゼンテーション層とドメイン層（ビジネスロジック層）の間を取り持つ役割も担う。

### ドメイン層

ソフトウェアを適用しようとしている領域で、問題解決に必要な知識を表現する。

**ドメインオブジェクト**はここに入る。

### インフラストラクチャ層

技術的基盤へのアクセスを提供する層。アプリケーションのためのメッセージ送信や、ドメインのための永続化を行うモジュールが含まれる。
アプリケーションのビジネスロジックやユーザーインターフェース層と直接的に関係しない部分であり、外部システムやサービス、ライブラリ、データベース、外部APIなどとのやり取りを担当する。

# Laravelで実装する

Laravelの`app/Http`ディレクトリは、アプリケーションへのリクエスト処理に関するほとんどのロジックが置かれる。`app/Http`ディレクトリ配下に、レイヤードアーキテクチャの各層のディレクトリを切る。

- app
    - Console
    - Http(※プレゼンテーション・UI層)
        - Controllers
        - Middleware
        - Request(基本的に、必須チェックや型のチェックのみ、業務知識に関するチェックはドメイン層で行う)
    - Application(※アプリケーション層)
        - UseCase
            - 各ユースケース
        - Dto
            - RequestクラスからUseCaseに渡すデータオブジェクト
            - テーブルINSERTするためのデータ構造
    - Domain(※ドメイン層)
        - Context(※コンテキストごと)
            - ValueObject
            - Entity
            - DomainService
            - Exception
            - Factory(Requestからエンティティを生成する、とか)
            - Repository(リポジトリインターフェースを置く)
    - Infrastructure(※インフラストラクチャ層)
        - EloquentModel
        - Repositoriy
    - Providers